import ImageColorSegmentation
import Foundation
import Metal

#if os(macOS)
import AppKit
import CoreGraphics
typealias PlatformImage = NSImage
#else
import UIKit
typealias PlatformImage = UIImage
#endif

// MARK: - Helper Functions

#if os(macOS)
/// Create NSImage from Metal buffer containing BGRA8 data
func createLayerImage(from buffer: MTLBuffer, width: Int, height: Int) -> NSImage? {
    // Metal buffer contains BGRA8 pixels (premultiplied alpha first)
    let bytesPerPixel = 4
    let bytesPerRow = width * bytesPerPixel
    let bitmapInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Little.rawValue

    guard let context = CGContext(
        data: buffer.contents(),
        width: width,
        height: height,
        bitsPerComponent: 8,
        bytesPerRow: bytesPerRow,
        space: CGColorSpaceCreateDeviceRGB(),
        bitmapInfo: bitmapInfo
    ) else {
        return nil
    }

    guard let cgImage = context.makeImage() else {
        return nil
    }

    return NSImage(cgImage: cgImage, size: NSSize(width: width, height: height))
}
#endif

// MARK: - Example 1: Basic Pipeline

func basicPipeline() async throws {
    #if os(macOS)
    // Load image from package resources
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png from resources")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png from resources")
        return
    }
    #endif

    print("üì∏ Loaded image: \(Int(image.size.width))x\(Int(image.size.height))")

    let pipeline = try ImagePipeline()
        .convertColorSpace(to: .lab, scale: .emphasizeGreens)
        .segment(superpixels: 1000, compactness: 25)
        .cluster(into: 5, seed: 42)
        .extractLayers()

    let result = try await pipeline.execute(input: image)

    // Access results
    print("‚úÖ Final type: \(result.finalType)")
    if let clusterCount: Int = result.metadata(for: "clusterCount") {
        print("‚úÖ Found \(clusterCount) clusters")

        // Create output directory
        let outputDir = FileManager.default.currentDirectoryPath + "/output_layers"
        try? FileManager.default.createDirectory(atPath: outputDir, withIntermediateDirectories: true)

        // Save layers
        print("\nüíæ Saving layers to: \(outputDir)/")

        let width = Int(image.size.width)
        let height = Int(image.size.height)

        // Extract and save actual color-separated layers from Metal buffers
        for i in 0..<clusterCount {
            #if os(macOS)
            // Get layer buffer from result
            guard let layerBuffer = result.buffer(named: "layer_\(i)") else {
                print("  ‚ö†Ô∏è  Warning: layer_\(i) buffer not found")
                continue
            }

            // Create image from Metal buffer containing BGRA8 pixel data
            guard let layerImage = createLayerImage(from: layerBuffer, width: width, height: height) else {
                print("  ‚ö†Ô∏è  Warning: Failed to create image from layer_\(i) buffer")
                continue
            }

            // Save as PNG
            if let tiffData = layerImage.tiffRepresentation,
               let bitmapImage = NSBitmapImageRep(data: tiffData),
               let pngData = bitmapImage.representation(using: .png, properties: [:]) {
                let filePath = "\(outputDir)/layer_\(i).png"
                try pngData.write(to: URL(fileURLWithPath: filePath))

                let bufferSize = layerBuffer.length
                let sizeKB = bufferSize / 1024
                print("  ‚úÖ Saved: layer_\(i).png (\(sizeKB)KB buffer ‚Üí \(pngData.count/1024)KB PNG)")
            }
            #else
            // iOS placeholder
            let filePath = "\(outputDir)/layer_\(i).png"
            if let pngData = image.pngData() {
                try pngData.write(to: URL(fileURLWithPath: filePath))
                print("  ‚úÖ Saved: layer_\(i).png")
            }
            #endif
        }

        // Create README explaining the layers
        let readmePath = "\(outputDir)/README.txt"
        let readmeContent = """
        ImageColorSegmentation Layer Export
        ====================================

        Color-separated layers generated by the BasicUsageExample using full
        Metal GPU-accelerated SLIC segmentation and K-means++ clustering.

        üìã Configuration:
        ‚Ä¢ Source image: test-icon.png (1024x1024)
        ‚Ä¢ Algorithm: SLIC + K-means++
        ‚Ä¢ Superpixels: 1000
        ‚Ä¢ Clusters: \(clusterCount)
        ‚Ä¢ LAB scale: emphasizeGreens (b-axis √ó 2.0)

        ‚úÖ Implementation Status:
        The pipeline uses production-ready Metal shaders for all operations:
        ‚Ä¢ RGB ‚Üí LAB color conversion with configurable axis scaling
        ‚Ä¢ SLIC superpixel segmentation (13 Metal kernels)
        ‚Ä¢ K-means++ clustering with smart initialization (11 Metal kernels)
        ‚Ä¢ GPU-accelerated layer extraction

        Each layer contains pixels from one color cluster, with alpha channel
        preserving the original transparency. Layers can be used for:
        ‚Ä¢ Icon design iteration (recolor individual elements)
        ‚Ä¢ Asset preparation (separate layers for different themes)
        ‚Ä¢ Color analysis (understand dominant colors)

        Generated: \(Date())
        """

        try? readmeContent.write(toFile: readmePath, atomically: true, encoding: .utf8)

        print("\n‚ú® Layers exported successfully!")
        print("   üìÅ Output: \(outputDir)")
        print("   üìÑ README: \(readmePath)")
        print("   üîç View: open \(outputDir)")
    }
}

// MARK: - Example 2: Reusable Template

func reusableTemplate() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    let template = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 5, seed: 42)
        .extractLayers()

    // Process same image multiple times as demo
    let result1 = try await template.execute(input: image)
    let result2 = try await template.execute(input: image)
    let result3 = try await template.execute(input: image)

    print("‚úÖ Processed 3 images")
}

// MARK: - Example 3: Batch Processing

func batchProcessing() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    // Use same image multiple times as demo
    let images = [image, image, image]

    let pipeline = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 5)
        .extractLayers()

    let results = try await pipeline.execute(inputs: images)

    for (index, result) in results.enumerated() {
        print("‚úÖ Image \(index): \(result.finalType)")
    }
}

// MARK: - Example 4: Pipeline Branching

func pipelineBranching() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    // Create parent pipeline up to SLIC (expensive operation)
    let slicPipeline = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)

    let slicResult = try await slicPipeline.execute(input: image)

    // Branch 1: Try 3 clusters
    let branch3 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 3, seed: 42)
        .extractLayers()

    // Branch 2: Try 5 clusters
    let branch5 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 5, seed: 42)
        .extractLayers()

    // Branch 3: Try 7 clusters
    let branch7 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 7, seed: 42)
        .extractLayers()

    // Execute all branches (reusing SLIC results)
    let result3 = try await branch3.execute(from: slicResult)
    let result5 = try await branch5.execute(from: slicResult)
    let result7 = try await branch7.execute(from: slicResult)

    print("Generated 3, 5, and 7 layer variants - SLIC only computed once!")
}

// MARK: - Example 5: Concurrent Branching

func concurrentBranching() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    // Parent pipeline
    let slicPipeline = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)

    let slicResult = try await slicPipeline.execute(input: image)

    // Create branches
    let branch3 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 3)
        .extractLayers()

    let branch5 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 5)
        .extractLayers()

    let branch7 = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 7)
        .extractLayers()

    // Execute all branches concurrently!
    async let r3 = branch3.execute(from: slicResult)
    async let r5 = branch5.execute(from: slicResult)
    async let r7 = branch7.execute(from: slicResult)

    let (result3, result5, result7) = try await (r3, r5, r7)

    print("All three variants computed in parallel!")
}

// MARK: - Example 6: Custom LAB Scaling

func customLABScaling() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    // Emphasize greens (common for nature/foliage)
    let greenPipeline = try ImagePipeline()
        .convertColorSpace(to: .lab, scale: .emphasizeGreens)  // b-axis scaled 2x
        .segment(superpixels: 1000)
        .cluster(into: 5)

    // Custom scaling for specific use case
    let customPipeline = try ImagePipeline()
        .convertColorSpace(to: .lab, scale: LABScale(l: 1.0, a: 1.5, b: 2.5))
        .segment(superpixels: 1000)
        .cluster(into: 5)

    let result1 = try await greenPipeline.execute(input: image)
    let result2 = try await customPipeline.execute(input: image)

    print("Processed with different LAB scalings")
}

// MARK: - Example 7: Multi-Stage Merging

func multiStageMerging() async throws {
    #if os(macOS)
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = NSImage(contentsOf: imageURL) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #else
    guard let imageURL = Bundle.module.url(forResource: "test-icon", withExtension: "png"),
          let image = UIImage(contentsOfFile: imageURL.path) else {
        print("‚ùå Failed to load test-icon.png")
        return
    }
    #endif

    let pipeline = try ImagePipeline()
        .convertColorSpace(to: .lab)
        .segment(superpixels: 1000)
        .cluster(into: 20)          // Start with many clusters
        .autoMerge(threshold: 0.20) // First merge pass
        .autoMerge(threshold: 0.35) // Second merge pass
        .extractLayers()

    let result = try await pipeline.execute(input: image)

    if let finalCount: Int = result.metadata(for: "clusterCount") {
        print("Reduced from 20 to \(finalCount) clusters through merging")
    }
}

// MARK: - Main

// Top-level async execution
Task {
    do {
        print("=== ImageColorSegmentation Examples ===\n")

        // Run examples
        try await basicPipeline()
        // try await reusableTemplate()
        // try await batchProcessing()
        // try await pipelineBranching()
        // try await concurrentBranching()
        // try await customLABScaling()
        // try await multiStageMerging()

        print("\nAll examples completed!")
        exit(0)
    } catch {
        print("\n‚ùå Error: \(error)")
        exit(1)
    }
}

// Keep the process alive until Task completes
dispatchMain()
